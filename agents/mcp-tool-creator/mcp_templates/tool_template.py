#!/usr/bin/env python3
"""
MCP Tool Template - Stdio Transport

Template for generating MCP tool servers. Produces a self-contained
Python script that implements the MCP protocol over stdio transport.

Used by: mcp_tool_creator.py (Phase 5 compound orchestrator)
Created: February 6, 2026
"""

# Template string - interpolated by generators with {placeholders}
TOOL_TEMPLATE = '''#!/usr/bin/env python3
"""
MCP Tool Server: {tool_name}

{description}

Transport: stdio
Protocol: MCP (Model Context Protocol)
Generated by: NLKE MCP Tool Creator (Phase 5)

Usage:
    python3 {filename} --stdio          # Run as MCP server
    python3 {filename} --test           # Run self-test
    python3 {filename} --list-tools     # List available tools
"""

import json
import sys
import os
from typing import Any, Dict, List, Optional


# ============================================================================
# Tool Definitions
# ============================================================================

TOOLS = {tools_json}

# ============================================================================
# Tool Handlers
# ============================================================================

{handler_functions}

# Handler dispatch
HANDLERS = {handlers_dict}

# ============================================================================
# MCP Protocol (stdio transport)
# ============================================================================

def read_message() -> Optional[Dict[str, Any]]:
    """Read a JSON-RPC message from stdin."""
    try:
        line = sys.stdin.readline()
        if not line:
            return None
        return json.loads(line.strip())
    except (json.JSONDecodeError, EOFError):
        return None


def write_message(msg: Dict[str, Any]) -> None:
    """Write a JSON-RPC message to stdout."""
    sys.stdout.write(json.dumps(msg) + "\\n")
    sys.stdout.flush()


def handle_initialize(params: Dict[str, Any]) -> Dict[str, Any]:
    """Handle initialize request."""
    return {{
        "protocolVersion": "2024-11-05",
        "capabilities": {{
            "tools": {{"listChanged": False}},
        }},
        "serverInfo": {{
            "name": "{tool_name}",
            "version": "{version}",
        }},
    }}


def handle_list_tools() -> Dict[str, Any]:
    """Handle tools/list request."""
    return {{"tools": TOOLS}}


def handle_call_tool(params: Dict[str, Any]) -> Dict[str, Any]:
    """Handle tools/call request."""
    name = params.get("name", "")
    arguments = params.get("arguments", {{}})

    handler = HANDLERS.get(name)
    if not handler:
        return {{
            "content": [{{
                "type": "text",
                "text": json.dumps({{"error": f"Unknown tool: {{name}}"}})
            }}],
            "isError": True,
        }}

    try:
        result = handler(**arguments)
        return {{
            "content": [{{
                "type": "text",
                "text": json.dumps(result, indent=2, default=str)
            }}],
        }}
    except Exception as e:
        return {{
            "content": [{{
                "type": "text",
                "text": json.dumps({{"error": str(e), "tool": name}})
            }}],
            "isError": True,
        }}


def run_stdio_server():
    """Main MCP server loop (stdio transport)."""
    while True:
        msg = read_message()
        if msg is None:
            break

        method = msg.get("method", "")
        msg_id = msg.get("id")
        params = msg.get("params", {{}})

        if method == "initialize":
            result = handle_initialize(params)
        elif method == "tools/list":
            result = handle_list_tools()
        elif method == "tools/call":
            result = handle_call_tool(params)
        elif method == "notifications/initialized":
            continue  # No response needed
        else:
            result = {{"error": f"Unknown method: {{method}}"}}

        if msg_id is not None:
            write_message({{"jsonrpc": "2.0", "id": msg_id, "result": result}})


# ============================================================================
# CLI
# ============================================================================

def self_test():
    """Run self-test on all tool handlers."""
    print(f"Testing {{len(TOOLS)}} tools...")
    for tool in TOOLS:
        name = tool["name"]
        print(f"  {{name}}: ", end="")
        handler = HANDLERS.get(name)
        if handler:
            try:
                # Try calling with empty args (may fail, that's ok)
                result = handler()
                print("OK")
            except TypeError:
                print("OK (requires arguments)")
            except Exception as e:
                print(f"ERROR: {{e}}")
        else:
            print("NO HANDLER")
    print("Self-test complete.")


if __name__ == "__main__":
    if "--stdio" in sys.argv:
        run_stdio_server()
    elif "--test" in sys.argv:
        self_test()
    elif "--list-tools" in sys.argv:
        for tool in TOOLS:
            print(f"  {{tool['name']}}: {{tool['description']}}")
    else:
        print(f"MCP Tool Server: {tool_name}")
        print(f"Tools: {{len(TOOLS)}}")
        print()
        print("Usage:")
        print(f"  python3 {filename} --stdio          # Run as MCP server")
        print(f"  python3 {filename} --test           # Self-test")
        print(f"  python3 {filename} --list-tools     # List tools")
'''

# Template for a single tool handler function
HANDLER_TEMPLATE = '''
def handle_{handler_name}({params_signature}) -> Dict[str, Any]:
    """{description}"""
    {handler_body}
'''

# Template for a simple passthrough handler that wraps an existing Python tool
PASSTHROUGH_HANDLER_TEMPLATE = '''
def handle_{handler_name}({params_signature}) -> Dict[str, Any]:
    """{description}

    Wraps: {wraps_tool}
    """
    try:
        # Import and run the wrapped tool
        sys.path.insert(0, "{tool_dir}")
        from {module_name} import {analyzer_class}
        from shared.agent_base import AgentInput

        analyzer = {analyzer_class}()
        agent_input = AgentInput(workload={{{input_mapping}}})
        result = analyzer.analyze(agent_input)
        return result.to_dict()
    except ImportError as e:
        return {{"error": f"Cannot import wrapped tool: {{e}}"}}
    except Exception as e:
        return {{"error": f"Execution failed: {{e}}"}}
'''
